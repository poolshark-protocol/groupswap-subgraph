// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class GroupOrder extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("groupAmount", Value.fromBigInt(BigInt.zero()));
    this.set("groupGwei", Value.fromBigInt(BigInt.zero()));
    this.set("fromToken", Value.fromBytes(Bytes.empty()));
    this.set("destToken", Value.fromBytes(Bytes.empty()));
    this.set("orderTxnHashes", Value.fromBytesArray(new Array(0)));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save GroupOrder entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save GroupOrder entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("GroupOrder", id.toString(), this);
    }
  }

  static load(id: string): GroupOrder | null {
    return changetype<GroupOrder | null>(store.get("GroupOrder", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get groupAmount(): BigInt {
    let value = this.get("groupAmount");
    return value!.toBigInt();
  }

  set groupAmount(value: BigInt) {
    this.set("groupAmount", Value.fromBigInt(value));
  }

  get groupGwei(): BigInt {
    let value = this.get("groupGwei");
    return value!.toBigInt();
  }

  set groupGwei(value: BigInt) {
    this.set("groupGwei", Value.fromBigInt(value));
  }

  get fromToken(): Bytes {
    let value = this.get("fromToken");
    return value!.toBytes();
  }

  set fromToken(value: Bytes) {
    this.set("fromToken", Value.fromBytes(value));
  }

  get destToken(): Bytes {
    let value = this.get("destToken");
    return value!.toBytes();
  }

  set destToken(value: Bytes) {
    this.set("destToken", Value.fromBytes(value));
  }

  get orderTxnHashes(): Array<Bytes> {
    let value = this.get("orderTxnHashes");
    return value!.toBytesArray();
  }

  set orderTxnHashes(value: Array<Bytes>) {
    this.set("orderTxnHashes", Value.fromBytesArray(value));
  }
}

export class UserAccount extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("groupAmounts", Value.fromString(""));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UserAccount entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save UserAccount entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("UserAccount", id.toString(), this);
    }
  }

  static load(id: string): UserAccount | null {
    return changetype<UserAccount | null>(store.get("UserAccount", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get groupAmounts(): string {
    let value = this.get("groupAmounts");
    return value!.toString();
  }

  set groupAmounts(value: string) {
    this.set("groupAmounts", Value.fromString(value));
  }
}

export class OpenOrder extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("account", Value.fromBytes(Bytes.empty()));
    this.set("groupId", Value.fromBytes(Bytes.empty()));
    this.set("fromToken", Value.fromBytes(Bytes.empty()));
    this.set("destToken", Value.fromBytes(Bytes.empty()));
    this.set("fromAmount", Value.fromBigInt(BigInt.zero()));
    this.set("gweiAdded", Value.fromBigInt(BigInt.zero()));
    this.set("blockNumber", Value.fromBigInt(BigInt.zero()));
    this.set("blockIndex", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OpenOrder entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OpenOrder entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OpenOrder", id.toString(), this);
    }
  }

  static load(id: string): OpenOrder | null {
    return changetype<OpenOrder | null>(store.get("OpenOrder", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get groupId(): Bytes {
    let value = this.get("groupId");
    return value!.toBytes();
  }

  set groupId(value: Bytes) {
    this.set("groupId", Value.fromBytes(value));
  }

  get fromToken(): Bytes {
    let value = this.get("fromToken");
    return value!.toBytes();
  }

  set fromToken(value: Bytes) {
    this.set("fromToken", Value.fromBytes(value));
  }

  get destToken(): Bytes {
    let value = this.get("destToken");
    return value!.toBytes();
  }

  set destToken(value: Bytes) {
    this.set("destToken", Value.fromBytes(value));
  }

  get fromAmount(): BigInt {
    let value = this.get("fromAmount");
    return value!.toBigInt();
  }

  set fromAmount(value: BigInt) {
    this.set("fromAmount", Value.fromBigInt(value));
  }

  get gweiAdded(): BigInt {
    let value = this.get("gweiAdded");
    return value!.toBigInt();
  }

  set gweiAdded(value: BigInt) {
    this.set("gweiAdded", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockIndex(): BigInt {
    let value = this.get("blockIndex");
    return value!.toBigInt();
  }

  set blockIndex(value: BigInt) {
    this.set("blockIndex", Value.fromBigInt(value));
  }
}

export class ExecutedOrder extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("account", Value.fromBytes(Bytes.empty()));
    this.set("groupId", Value.fromBytes(Bytes.empty()));
    this.set("fromToken", Value.fromBytes(Bytes.empty()));
    this.set("destToken", Value.fromBytes(Bytes.empty()));
    this.set("destAmount", Value.fromBigInt(BigInt.zero()));
    this.set("gweiLeft", Value.fromBigInt(BigInt.zero()));
    this.set("groupTxnHash", Value.fromBigInt(BigInt.zero()));
    this.set("blockNumber", Value.fromBigInt(BigInt.zero()));
    this.set("blockIndex", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ExecutedOrder entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save ExecutedOrder entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("ExecutedOrder", id.toString(), this);
    }
  }

  static load(id: string): ExecutedOrder | null {
    return changetype<ExecutedOrder | null>(store.get("ExecutedOrder", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get groupId(): Bytes {
    let value = this.get("groupId");
    return value!.toBytes();
  }

  set groupId(value: Bytes) {
    this.set("groupId", Value.fromBytes(value));
  }

  get fromToken(): Bytes {
    let value = this.get("fromToken");
    return value!.toBytes();
  }

  set fromToken(value: Bytes) {
    this.set("fromToken", Value.fromBytes(value));
  }

  get destToken(): Bytes {
    let value = this.get("destToken");
    return value!.toBytes();
  }

  set destToken(value: Bytes) {
    this.set("destToken", Value.fromBytes(value));
  }

  get destAmount(): BigInt {
    let value = this.get("destAmount");
    return value!.toBigInt();
  }

  set destAmount(value: BigInt) {
    this.set("destAmount", Value.fromBigInt(value));
  }

  get gweiLeft(): BigInt {
    let value = this.get("gweiLeft");
    return value!.toBigInt();
  }

  set gweiLeft(value: BigInt) {
    this.set("gweiLeft", Value.fromBigInt(value));
  }

  get groupTxnHash(): BigInt {
    let value = this.get("groupTxnHash");
    return value!.toBigInt();
  }

  set groupTxnHash(value: BigInt) {
    this.set("groupTxnHash", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockIndex(): BigInt {
    let value = this.get("blockIndex");
    return value!.toBigInt();
  }

  set blockIndex(value: BigInt) {
    this.set("blockIndex", Value.fromBigInt(value));
  }
}

export class CancelledOrder extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("account", Value.fromBytes(Bytes.empty()));
    this.set("fromToken", Value.fromBytes(Bytes.empty()));
    this.set("destToken", Value.fromBytes(Bytes.empty()));
    this.set("depositTxnHash", Value.fromBytes(Bytes.empty()));
    this.set("withdrawTxnHash", Value.fromBytes(Bytes.empty()));
    this.set("transferTxnHash", Value.fromBytes(Bytes.empty()));
    this.set("fromAmount", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save CancelledOrder entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save CancelledOrder entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("CancelledOrder", id.toString(), this);
    }
  }

  static load(id: string): CancelledOrder | null {
    return changetype<CancelledOrder | null>(store.get("CancelledOrder", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get fromToken(): Bytes {
    let value = this.get("fromToken");
    return value!.toBytes();
  }

  set fromToken(value: Bytes) {
    this.set("fromToken", Value.fromBytes(value));
  }

  get destToken(): Bytes {
    let value = this.get("destToken");
    return value!.toBytes();
  }

  set destToken(value: Bytes) {
    this.set("destToken", Value.fromBytes(value));
  }

  get depositTxnHash(): Bytes {
    let value = this.get("depositTxnHash");
    return value!.toBytes();
  }

  set depositTxnHash(value: Bytes) {
    this.set("depositTxnHash", Value.fromBytes(value));
  }

  get withdrawTxnHash(): Bytes {
    let value = this.get("withdrawTxnHash");
    return value!.toBytes();
  }

  set withdrawTxnHash(value: Bytes) {
    this.set("withdrawTxnHash", Value.fromBytes(value));
  }

  get transferTxnHash(): Bytes {
    let value = this.get("transferTxnHash");
    return value!.toBytes();
  }

  set transferTxnHash(value: Bytes) {
    this.set("transferTxnHash", Value.fromBytes(value));
  }

  get fromAmount(): BigInt {
    let value = this.get("fromAmount");
    return value!.toBigInt();
  }

  set fromAmount(value: BigInt) {
    this.set("fromAmount", Value.fromBigInt(value));
  }
}

export class CompletedOrder extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("account", Value.fromBytes(Bytes.empty()));
    this.set("fromToken", Value.fromBytes(Bytes.empty()));
    this.set("destToken", Value.fromBytes(Bytes.empty()));
    this.set("destAmount", Value.fromBigInt(BigInt.zero()));
    this.set("groupTxnHash", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save CompletedOrder entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save CompletedOrder entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("CompletedOrder", id.toString(), this);
    }
  }

  static load(id: string): CompletedOrder | null {
    return changetype<CompletedOrder | null>(store.get("CompletedOrder", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get fromToken(): Bytes {
    let value = this.get("fromToken");
    return value!.toBytes();
  }

  set fromToken(value: Bytes) {
    this.set("fromToken", Value.fromBytes(value));
  }

  get destToken(): Bytes {
    let value = this.get("destToken");
    return value!.toBytes();
  }

  set destToken(value: Bytes) {
    this.set("destToken", Value.fromBytes(value));
  }

  get destAmount(): BigInt {
    let value = this.get("destAmount");
    return value!.toBigInt();
  }

  set destAmount(value: BigInt) {
    this.set("destAmount", Value.fromBigInt(value));
  }

  get groupTxnHash(): Bytes {
    let value = this.get("groupTxnHash");
    return value!.toBytes();
  }

  set groupTxnHash(value: Bytes) {
    this.set("groupTxnHash", Value.fromBytes(value));
  }
}

export class GroupExecution extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("groupId", Value.fromBytes(Bytes.empty()));
    this.set("inputAmount", Value.fromBigInt(BigInt.zero()));
    this.set("returnAmount", Value.fromBigInt(BigInt.zero()));
    this.set("returnAmountLeft", Value.fromBigInt(BigInt.zero()));
    this.set("usedGas", Value.fromBigInt(BigInt.zero()));
    this.set("compltdTxnHashes", Value.fromBytesArray(new Array(0)));
    this.set("blockNumber", Value.fromBigInt(BigInt.zero()));
    this.set("blockIndex", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save GroupExecution entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save GroupExecution entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("GroupExecution", id.toString(), this);
    }
  }

  static load(id: string): GroupExecution | null {
    return changetype<GroupExecution | null>(store.get("GroupExecution", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get groupId(): Bytes {
    let value = this.get("groupId");
    return value!.toBytes();
  }

  set groupId(value: Bytes) {
    this.set("groupId", Value.fromBytes(value));
  }

  get inputAmount(): BigInt {
    let value = this.get("inputAmount");
    return value!.toBigInt();
  }

  set inputAmount(value: BigInt) {
    this.set("inputAmount", Value.fromBigInt(value));
  }

  get returnAmount(): BigInt {
    let value = this.get("returnAmount");
    return value!.toBigInt();
  }

  set returnAmount(value: BigInt) {
    this.set("returnAmount", Value.fromBigInt(value));
  }

  get returnAmountLeft(): BigInt {
    let value = this.get("returnAmountLeft");
    return value!.toBigInt();
  }

  set returnAmountLeft(value: BigInt) {
    this.set("returnAmountLeft", Value.fromBigInt(value));
  }

  get usedGas(): BigInt {
    let value = this.get("usedGas");
    return value!.toBigInt();
  }

  set usedGas(value: BigInt) {
    this.set("usedGas", Value.fromBigInt(value));
  }

  get compltdTxnHashes(): Array<Bytes> {
    let value = this.get("compltdTxnHashes");
    return value!.toBytesArray();
  }

  set compltdTxnHashes(value: Array<Bytes>) {
    this.set("compltdTxnHashes", Value.fromBytesArray(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockIndex(): BigInt {
    let value = this.get("blockIndex");
    return value!.toBigInt();
  }

  set blockIndex(value: BigInt) {
    this.set("blockIndex", Value.fromBigInt(value));
  }
}

export class CancelRequest extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("account", Value.fromBytes(Bytes.empty()));
    this.set("groupId", Value.fromBytes(Bytes.empty()));
    this.set("withdrawToken", Value.fromBytes(Bytes.empty()));
    this.set("amount", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save CancelRequest entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save CancelRequest entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("CancelRequest", id.toString(), this);
    }
  }

  static load(id: string): CancelRequest | null {
    return changetype<CancelRequest | null>(store.get("CancelRequest", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get groupId(): Bytes {
    let value = this.get("groupId");
    return value!.toBytes();
  }

  set groupId(value: Bytes) {
    this.set("groupId", Value.fromBytes(value));
  }

  get withdrawToken(): Bytes {
    let value = this.get("withdrawToken");
    return value!.toBytes();
  }

  set withdrawToken(value: Bytes) {
    this.set("withdrawToken", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class WithdrawRequest extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("account", Value.fromBytes(Bytes.empty()));
    this.set("groupId", Value.fromBytes(Bytes.empty()));
    this.set("withdrawToken", Value.fromBytes(Bytes.empty()));
    this.set("amount", Value.fromBigInt(BigInt.zero()));
    this.set("groupTxnHash", Value.fromBytes(Bytes.empty()));
    this.set("withdrawTxnHash", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save WithdrawRequest entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save WithdrawRequest entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("WithdrawRequest", id.toString(), this);
    }
  }

  static load(id: string): WithdrawRequest | null {
    return changetype<WithdrawRequest | null>(store.get("WithdrawRequest", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get groupId(): Bytes {
    let value = this.get("groupId");
    return value!.toBytes();
  }

  set groupId(value: Bytes) {
    this.set("groupId", Value.fromBytes(value));
  }

  get withdrawToken(): Bytes {
    let value = this.get("withdrawToken");
    return value!.toBytes();
  }

  set withdrawToken(value: Bytes) {
    this.set("withdrawToken", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get groupTxnHash(): Bytes {
    let value = this.get("groupTxnHash");
    return value!.toBytes();
  }

  set groupTxnHash(value: Bytes) {
    this.set("groupTxnHash", Value.fromBytes(value));
  }

  get withdrawTxnHash(): Bytes {
    let value = this.get("withdrawTxnHash");
    return value!.toBytes();
  }

  set withdrawTxnHash(value: Bytes) {
    this.set("withdrawTxnHash", Value.fromBytes(value));
  }
}

export class WithdrawApproved extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("address", Value.fromBytes(Bytes.empty()));
    this.set("groupIds", Value.fromBytesArray(new Array(0)));
    this.set("amounts", Value.fromBigIntArray(new Array(0)));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save WithdrawApproved entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save WithdrawApproved entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("WithdrawApproved", id.toString(), this);
    }
  }

  static load(id: string): WithdrawApproved | null {
    return changetype<WithdrawApproved | null>(
      store.get("WithdrawApproved", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get groupIds(): Array<Bytes> {
    let value = this.get("groupIds");
    return value!.toBytesArray();
  }

  set groupIds(value: Array<Bytes>) {
    this.set("groupIds", Value.fromBytesArray(value));
  }

  get amounts(): Array<BigInt> {
    let value = this.get("amounts");
    return value!.toBigIntArray();
  }

  set amounts(value: Array<BigInt>) {
    this.set("amounts", Value.fromBigIntArray(value));
  }
}

export class WithdrawDeclined extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("address", Value.fromBytes(Bytes.empty()));
    this.set("groupIds", Value.fromBytesArray(new Array(0)));
    this.set("amounts", Value.fromBigIntArray(new Array(0)));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save WithdrawDeclined entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save WithdrawDeclined entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("WithdrawDeclined", id.toString(), this);
    }
  }

  static load(id: string): WithdrawDeclined | null {
    return changetype<WithdrawDeclined | null>(
      store.get("WithdrawDeclined", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get groupIds(): Array<Bytes> {
    let value = this.get("groupIds");
    return value!.toBytesArray();
  }

  set groupIds(value: Array<Bytes>) {
    this.set("groupIds", Value.fromBytesArray(value));
  }

  get amounts(): Array<BigInt> {
    let value = this.get("amounts");
    return value!.toBigIntArray();
  }

  set amounts(value: Array<BigInt>) {
    this.set("amounts", Value.fromBigIntArray(value));
  }
}
