// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class GroupOrder extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("groupAmount", Value.fromBigInt(BigInt.zero()));
    this.set("groupGwei", Value.fromBigInt(BigInt.zero()));
    this.set("fromToken", Value.fromBytes(Bytes.empty()));
    this.set("destToken", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save GroupOrder entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save GroupOrder entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("GroupOrder", id.toString(), this);
    }
  }

  static load(id: string): GroupOrder | null {
    return changetype<GroupOrder | null>(store.get("GroupOrder", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get groupAmount(): BigInt {
    let value = this.get("groupAmount");
    return value!.toBigInt();
  }

  set groupAmount(value: BigInt) {
    this.set("groupAmount", Value.fromBigInt(value));
  }

  get groupGwei(): BigInt {
    let value = this.get("groupGwei");
    return value!.toBigInt();
  }

  set groupGwei(value: BigInt) {
    this.set("groupGwei", Value.fromBigInt(value));
  }

  get fromToken(): Bytes {
    let value = this.get("fromToken");
    return value!.toBytes();
  }

  set fromToken(value: Bytes) {
    this.set("fromToken", Value.fromBytes(value));
  }

  get destToken(): Bytes {
    let value = this.get("destToken");
    return value!.toBytes();
  }

  set destToken(value: Bytes) {
    this.set("destToken", Value.fromBytes(value));
  }
}

export class UserAccount extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("groupAmounts", Value.fromString(""));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UserAccount entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save UserAccount entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("UserAccount", id.toString(), this);
    }
  }

  static load(id: string): UserAccount | null {
    return changetype<UserAccount | null>(store.get("UserAccount", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get groupAmounts(): string {
    let value = this.get("groupAmounts");
    return value!.toString();
  }

  set groupAmounts(value: string) {
    this.set("groupAmounts", Value.fromString(value));
  }
}

export class UserOrder extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("account", Value.fromBytes(Bytes.empty()));
    this.set("fromToken", Value.fromBytes(Bytes.empty()));
    this.set("destToken", Value.fromBytes(Bytes.empty()));
    this.set("fromAmount", Value.fromBigInt(BigInt.zero()));
    this.set("gweiAdded", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UserOrder entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save UserOrder entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("UserOrder", id.toString(), this);
    }
  }

  static load(id: string): UserOrder | null {
    return changetype<UserOrder | null>(store.get("UserOrder", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get fromToken(): Bytes {
    let value = this.get("fromToken");
    return value!.toBytes();
  }

  set fromToken(value: Bytes) {
    this.set("fromToken", Value.fromBytes(value));
  }

  get destToken(): Bytes {
    let value = this.get("destToken");
    return value!.toBytes();
  }

  set destToken(value: Bytes) {
    this.set("destToken", Value.fromBytes(value));
  }

  get fromAmount(): BigInt {
    let value = this.get("fromAmount");
    return value!.toBigInt();
  }

  set fromAmount(value: BigInt) {
    this.set("fromAmount", Value.fromBigInt(value));
  }

  get gweiAdded(): BigInt {
    let value = this.get("gweiAdded");
    return value!.toBigInt();
  }

  set gweiAdded(value: BigInt) {
    this.set("gweiAdded", Value.fromBigInt(value));
  }
}

export class GroupExecuted extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("groupId", Value.fromBytes(Bytes.empty()));
    this.set("returnAmount", Value.fromBigInt(BigInt.zero()));
    this.set("usedGas", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save GroupExecuted entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save GroupExecuted entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("GroupExecuted", id.toString(), this);
    }
  }

  static load(id: string): GroupExecuted | null {
    return changetype<GroupExecuted | null>(store.get("GroupExecuted", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get groupId(): Bytes {
    let value = this.get("groupId");
    return value!.toBytes();
  }

  set groupId(value: Bytes) {
    this.set("groupId", Value.fromBytes(value));
  }

  get returnAmount(): BigInt {
    let value = this.get("returnAmount");
    return value!.toBigInt();
  }

  set returnAmount(value: BigInt) {
    this.set("returnAmount", Value.fromBigInt(value));
  }

  get usedGas(): BigInt {
    let value = this.get("usedGas");
    return value!.toBigInt();
  }

  set usedGas(value: BigInt) {
    this.set("usedGas", Value.fromBigInt(value));
  }
}

export class WithdrawRequest extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("address", Value.fromBytes(Bytes.empty()));
    this.set("groupIds", Value.fromBytesArray(new Array(0)));
    this.set("amounts", Value.fromBigIntArray(new Array(0)));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save WithdrawRequest entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save WithdrawRequest entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("WithdrawRequest", id.toString(), this);
    }
  }

  static load(id: string): WithdrawRequest | null {
    return changetype<WithdrawRequest | null>(store.get("WithdrawRequest", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get groupIds(): Array<Bytes> {
    let value = this.get("groupIds");
    return value!.toBytesArray();
  }

  set groupIds(value: Array<Bytes>) {
    this.set("groupIds", Value.fromBytesArray(value));
  }

  get amounts(): Array<BigInt> {
    let value = this.get("amounts");
    return value!.toBigIntArray();
  }

  set amounts(value: Array<BigInt>) {
    this.set("amounts", Value.fromBigIntArray(value));
  }
}

export class WithdrawApproved extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("address", Value.fromBytes(Bytes.empty()));
    this.set("groupIds", Value.fromBytesArray(new Array(0)));
    this.set("amounts", Value.fromBigIntArray(new Array(0)));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save WithdrawApproved entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save WithdrawApproved entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("WithdrawApproved", id.toString(), this);
    }
  }

  static load(id: string): WithdrawApproved | null {
    return changetype<WithdrawApproved | null>(
      store.get("WithdrawApproved", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get groupIds(): Array<Bytes> {
    let value = this.get("groupIds");
    return value!.toBytesArray();
  }

  set groupIds(value: Array<Bytes>) {
    this.set("groupIds", Value.fromBytesArray(value));
  }

  get amounts(): Array<BigInt> {
    let value = this.get("amounts");
    return value!.toBigIntArray();
  }

  set amounts(value: Array<BigInt>) {
    this.set("amounts", Value.fromBigIntArray(value));
  }
}

export class WithdrawDeclined extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("address", Value.fromBytes(Bytes.empty()));
    this.set("groupIds", Value.fromBytesArray(new Array(0)));
    this.set("amounts", Value.fromBigIntArray(new Array(0)));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save WithdrawDeclined entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save WithdrawDeclined entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("WithdrawDeclined", id.toString(), this);
    }
  }

  static load(id: string): WithdrawDeclined | null {
    return changetype<WithdrawDeclined | null>(
      store.get("WithdrawDeclined", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get groupIds(): Array<Bytes> {
    let value = this.get("groupIds");
    return value!.toBytesArray();
  }

  set groupIds(value: Array<Bytes>) {
    this.set("groupIds", Value.fromBytesArray(value));
  }

  get amounts(): Array<BigInt> {
    let value = this.get("amounts");
    return value!.toBigIntArray();
  }

  set amounts(value: Array<BigInt>) {
    this.set("amounts", Value.fromBigIntArray(value));
  }
}
