// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class GroupData extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("groupAmount", Value.fromBigInt(BigInt.zero()));
    this.set("groupGwei", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save GroupData entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save GroupData entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("GroupData", id.toString(), this);
    }
  }

  static load(id: string): GroupData | null {
    return changetype<GroupData | null>(store.get("GroupData", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get groupAmount(): BigInt {
    let value = this.get("groupAmount");
    return value!.toBigInt();
  }

  set groupAmount(value: BigInt) {
    this.set("groupAmount", Value.fromBigInt(value));
  }

  get groupGwei(): BigInt {
    let value = this.get("groupGwei");
    return value!.toBigInt();
  }

  set groupGwei(value: BigInt) {
    this.set("groupGwei", Value.fromBigInt(value));
  }
}

export class UserData extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("groupAmounts", Value.fromString(""));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UserData entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save UserData entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("UserData", id.toString(), this);
    }
  }

  static load(id: string): UserData | null {
    return changetype<UserData | null>(store.get("UserData", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get groupAmounts(): string {
    let value = this.get("groupAmounts");
    return value!.toString();
  }

  set groupAmounts(value: string) {
    this.set("groupAmounts", Value.fromString(value));
  }
}

export class OrderData extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("fromToken", Value.fromBytes(Bytes.empty()));
    this.set("destToken", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OrderData entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OrderData entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OrderData", id.toString(), this);
    }
  }

  static load(id: string): OrderData | null {
    return changetype<OrderData | null>(store.get("OrderData", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromToken(): Bytes {
    let value = this.get("fromToken");
    return value!.toBytes();
  }

  set fromToken(value: Bytes) {
    this.set("fromToken", Value.fromBytes(value));
  }

  get destToken(): Bytes {
    let value = this.get("destToken");
    return value!.toBytes();
  }

  set destToken(value: Bytes) {
    this.set("destToken", Value.fromBytes(value));
  }

  get fromAmount(): BigInt | null {
    let value = this.get("fromAmount");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set fromAmount(value: BigInt | null) {
    if (!value) {
      this.unset("fromAmount");
    } else {
      this.set("fromAmount", Value.fromBigInt(<BigInt>value));
    }
  }
}

export class GroupExecuted extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("groupId", Value.fromBytes(Bytes.empty()));
    this.set("returnAmount", Value.fromBigInt(BigInt.zero()));
    this.set("usedGas", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save GroupExecuted entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save GroupExecuted entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("GroupExecuted", id.toString(), this);
    }
  }

  static load(id: string): GroupExecuted | null {
    return changetype<GroupExecuted | null>(store.get("GroupExecuted", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get groupId(): Bytes {
    let value = this.get("groupId");
    return value!.toBytes();
  }

  set groupId(value: Bytes) {
    this.set("groupId", Value.fromBytes(value));
  }

  get returnAmount(): BigInt {
    let value = this.get("returnAmount");
    return value!.toBigInt();
  }

  set returnAmount(value: BigInt) {
    this.set("returnAmount", Value.fromBigInt(value));
  }

  get usedGas(): BigInt {
    let value = this.get("usedGas");
    return value!.toBigInt();
  }

  set usedGas(value: BigInt) {
    this.set("usedGas", Value.fromBigInt(value));
  }
}

export class WithdrawRequest extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("address", Value.fromBytes(Bytes.empty()));
    this.set("groupIds", Value.fromBytesArray(new Array(0)));
    this.set("amounts", Value.fromBigIntArray(new Array(0)));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save WithdrawRequest entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save WithdrawRequest entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("WithdrawRequest", id.toString(), this);
    }
  }

  static load(id: string): WithdrawRequest | null {
    return changetype<WithdrawRequest | null>(store.get("WithdrawRequest", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get groupIds(): Array<Bytes> {
    let value = this.get("groupIds");
    return value!.toBytesArray();
  }

  set groupIds(value: Array<Bytes>) {
    this.set("groupIds", Value.fromBytesArray(value));
  }

  get amounts(): Array<BigInt> {
    let value = this.get("amounts");
    return value!.toBigIntArray();
  }

  set amounts(value: Array<BigInt>) {
    this.set("amounts", Value.fromBigIntArray(value));
  }
}

export class WithdrawApproved extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("address", Value.fromBytes(Bytes.empty()));
    this.set("groupIds", Value.fromBytesArray(new Array(0)));
    this.set("amounts", Value.fromBigIntArray(new Array(0)));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save WithdrawApproved entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save WithdrawApproved entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("WithdrawApproved", id.toString(), this);
    }
  }

  static load(id: string): WithdrawApproved | null {
    return changetype<WithdrawApproved | null>(
      store.get("WithdrawApproved", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get groupIds(): Array<Bytes> {
    let value = this.get("groupIds");
    return value!.toBytesArray();
  }

  set groupIds(value: Array<Bytes>) {
    this.set("groupIds", Value.fromBytesArray(value));
  }

  get amounts(): Array<BigInt> {
    let value = this.get("amounts");
    return value!.toBigIntArray();
  }

  set amounts(value: Array<BigInt>) {
    this.set("amounts", Value.fromBigIntArray(value));
  }
}

export class WithdrawDeclined extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("address", Value.fromBytes(Bytes.empty()));
    this.set("groupIds", Value.fromBytesArray(new Array(0)));
    this.set("amounts", Value.fromBigIntArray(new Array(0)));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save WithdrawDeclined entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save WithdrawDeclined entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("WithdrawDeclined", id.toString(), this);
    }
  }

  static load(id: string): WithdrawDeclined | null {
    return changetype<WithdrawDeclined | null>(
      store.get("WithdrawDeclined", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get groupIds(): Array<Bytes> {
    let value = this.get("groupIds");
    return value!.toBytesArray();
  }

  set groupIds(value: Array<Bytes>) {
    this.set("groupIds", Value.fromBytesArray(value));
  }

  get amounts(): Array<BigInt> {
    let value = this.get("amounts");
    return value!.toBigIntArray();
  }

  set amounts(value: Array<BigInt>) {
    this.set("amounts", Value.fromBigIntArray(value));
  }
}
